name: Electron Release

on:
  # Manual trigger for releases
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., 1.0.0, 1.2.3-beta.1)'
        required: true
        type: string
      prerelease:
        description: 'Mark as pre-release'
        required: false
        default: false
        type: boolean
  # Trigger after successful CI on main branch
  workflow_run:
    workflows: ['CI']
    branches: [main]
    types: [completed]

concurrency:
  group: release
  cancel-in-progress: false

jobs:
  # Only run if CI passed or manual trigger
  check-trigger:
    name: Check Release Trigger
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      is_manual: ${{ steps.check.outputs.is_manual }}
      input_version: ${{ steps.check.outputs.input_version }}
      input_prerelease: ${{ steps.check.outputs.input_prerelease }}
    steps:
      - name: Check if release should proceed
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Manual release triggered"
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "is_manual=true" >> $GITHUB_OUTPUT
            echo "input_version=${{ inputs.version }}" >> $GITHUB_OUTPUT
            echo "input_prerelease=${{ inputs.prerelease }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "workflow_run" && "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
            echo "CI passed - auto release enabled"
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "is_manual=false" >> $GITHUB_OUTPUT
            echo "input_version=" >> $GITHUB_OUTPUT
            echo "input_prerelease=false" >> $GITHUB_OUTPUT
          else
            echo "Release conditions not met"
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "is_manual=false" >> $GITHUB_OUTPUT
            echo "input_version=" >> $GITHUB_OUTPUT
            echo "input_prerelease=false" >> $GITHUB_OUTPUT
          fi  # Create tag and update version
  create-tag:
    name: Create Release Tag
    runs-on: ubuntu-latest
    needs: [check-trigger]
    if: needs.check-trigger.outputs.should_release == 'true'
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      prerelease: ${{ steps.version.outputs.prerelease }}
      release_branch: ${{ steps.version_update.outputs.release_branch }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Fetch all tags
        run: |
          git fetch --tags --force
          echo "üìã Current tags:"
          git tag -l | head -10

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Setup Node.js
        uses: actions/setup-node@v5
        with:
          node-version: '18'
          cache: 'pnpm'

      - name: Determine version information
        id: version
        run: |
          if [[ "${{ needs.check-trigger.outputs.is_manual }}" == "true" ]]; then
            VERSION="${{ needs.check-trigger.outputs.input_version }}"
            PRERELEASE="${{ needs.check-trigger.outputs.input_prerelease }}"
            echo "üìã Manual release version: $VERSION"
          else
            # Auto-increment patch version based on latest git tag
            echo "üîç Determining next auto-release version..."
            
            # Get the latest tag (if any)
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "Latest tag: $LATEST_TAG"
            
            # Remove 'v' prefix for version parsing
            LATEST_VERSION=${LATEST_TAG#v}
            
            # Get current version from package.json as fallback
            PACKAGE_VERSION=$(node -p "require('./package.json').version")
            echo "Package.json version: $PACKAGE_VERSION"
            
            # Use the higher version as base
            if [[ "$LATEST_VERSION" != "0.0.0" ]]; then
              # Compare versions and use the higher one
              if [[ $(printf '%s\n' "$LATEST_VERSION" "$PACKAGE_VERSION" | sort -V | tail -n1) == "$LATEST_VERSION" ]]; then
                CURRENT_VERSION="$LATEST_VERSION"
                echo "Using latest tag version: $CURRENT_VERSION"
              else
                CURRENT_VERSION="$PACKAGE_VERSION"  
                echo "Using package.json version: $CURRENT_VERSION"
              fi
            else
              CURRENT_VERSION="$PACKAGE_VERSION"
              echo "No tags found, using package.json version: $CURRENT_VERSION"
            fi
            
            # Auto-increment patch version
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]}
            PATCH=${VERSION_PARTS[2]}
            NEW_PATCH=$((PATCH + 1))
            VERSION="$MAJOR.$MINOR.$NEW_PATCH"
            PRERELEASE="false"
            
            echo "Auto-incremented to: $VERSION"
          fi

          # Handle tag conflicts by finding next available version
          ORIGINAL_VERSION="$VERSION"
          TAG="v$VERSION"
          ATTEMPT=0
          MAX_ATTEMPTS=10

          while git rev-parse "$TAG" >/dev/null 2>&1; do
            ATTEMPT=$((ATTEMPT + 1))
            if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
              echo "‚ùå Error: Could not find available version after $MAX_ATTEMPTS attempts"
              echo "Latest attempted: $TAG"
              echo "Please manually resolve version conflicts"
              exit 1
            fi
            
            echo "‚ö†Ô∏è  Tag $TAG already exists, incrementing..."
            
            # Parse current version and increment patch
            IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]}
            PATCH=${VERSION_PARTS[2]}
            NEW_PATCH=$((PATCH + 1))
            VERSION="$MAJOR.$MINOR.$NEW_PATCH"
            TAG="v$VERSION"
          done

          if [ "$VERSION" != "$ORIGINAL_VERSION" ]; then
            echo "üîÑ Version auto-adjusted from $ORIGINAL_VERSION to $VERSION to avoid conflicts"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "prerelease=$PRERELEASE" >> $GITHUB_OUTPUT

          echo "‚úÖ Release version: $VERSION"
          echo "‚úÖ Tag: $TAG"
          echo "‚úÖ Pre-release: $PRERELEASE"

      - name: Update package.json version
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"
          RELEASE_BRANCH="release/$TAG"

          echo "Updating package.json to version $VERSION"
          npm version $VERSION --no-git-tag-version

          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Create release branch from current main
          git checkout -b $RELEASE_BRANCH

          # Commit version update
          git add package.json
          git commit -m "chore: bump version to $VERSION [skip ci]"

          # Push release branch
          if git push origin $RELEASE_BRANCH; then
            echo "‚úÖ Successfully pushed release branch $RELEASE_BRANCH"
          else
            echo "‚ùå Failed to push release branch $RELEASE_BRANCH"
            exit 1
          fi

          # Create tag from release branch
          if git tag -a $TAG -m "Release $TAG"; then
            echo "‚úÖ Successfully created tag $TAG"
          else
            echo "‚ùå Failed to create tag $TAG"
            exit 1
          fi

          # Push tag
          if git push origin $TAG; then
            echo "‚úÖ Successfully pushed tag $TAG"
          else
            echo "‚ùå Failed to push tag $TAG"
            # Clean up: delete local tag if push failed
            git tag -d $TAG
            exit 1
          fi

          echo "‚úÖ Created tag $TAG and release branch $RELEASE_BRANCH"
          echo "release_branch=$RELEASE_BRANCH" >> $GITHUB_OUTPUT
        id: version_update

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}
          branch: ${{ steps.version_update.outputs.release_branch }}
          base: main
          title: 'üöÄ Release ${{ steps.version.outputs.tag }}'
          body: |
            ## üöÄ Release ${{ steps.version.outputs.tag }}

            This PR contains the version bump for the upcoming release.

            ### Changes
            - üì¶ Bump version to `${{ steps.version.outputs.version }}` in package.json
            - üè∑Ô∏è Tag `${{ steps.version.outputs.tag }}` has been created            ### Release Process
            1. ‚úÖ Version updated and tagged
            2. üîÑ Building packages for all platforms
            3. üìù GitHub release will be created automatically

            **This PR can be merged immediately** - the release process is already underway.

            ---

            _This PR was created automatically by the release workflow._
          labels: |
            release
            automated
          draft: false

  # Build packages for all platforms
  build-packages:
    name: Build Packages
    needs: [create-tag]
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            platform: linux
          - os: windows-latest
            platform: windows
          - os: macos-latest
            platform: macos

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.create-tag.outputs.tag }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: latest

      - name: Setup Node.js
        uses: actions/setup-node@v5
        with:
          node-version: '18'
          cache: 'pnpm'

      - name: Install system dependencies (Linux)
        if: matrix.platform == 'linux'
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y \
            libnss3-dev \
            libatk-bridge2.0-dev \
            libdrm2 \
            libgtk-3-0 \
            libgbm-dev \
            libxss1 \
            libxtst6 \
            libxrandr2 \
            libasound2t64 \
            libpangocairo-1.0-0 \
            libatk1.0-0 \
            libcairo-gobject2 \
            libgtk-3-0 \
            libgdk-pixbuf2.0-0

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build application
        run: pnpm run build

      - name: Package for Linux
        if: matrix.platform == 'linux'
        run: |
          # Build without publishing to avoid auto-publish issues
          pnpm run build && electron-builder --linux --publish never
          echo "üì¶ Linux packages created:"
          ls -la release/build/
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES: true

      - name: Package for Windows
        if: matrix.platform == 'windows'
        shell: pwsh
        run: |
          # Build without publishing to avoid auto-publish issues
          pnpm run build && electron-builder --win --publish never
          Write-Host "üì¶ Windows packages created:"
          Get-ChildItem release/build/
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CSC_IDENTITY_AUTO_DISCOVERY: false
          ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES: true

      - name: Package for macOS
        if: matrix.platform == 'macos'
        run: |
          # Build without publishing to avoid auto-publish issues
          pnpm run build && electron-builder --mac --publish never
          echo "üì¶ macOS packages created:"
          ls -la release/build/
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CSC_IDENTITY_AUTO_DISCOVERY: false
          ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES: true

      - name: Upload Linux artifacts
        if: matrix.platform == 'linux'
        uses: actions/upload-artifact@v4
        with:
          name: linux-packages
          path: |
            release/build/*.AppImage
            release/build/*.deb
            release/build/*.rpm
            release/build/*.snap
          retention-days: 90

      - name: Upload Windows artifacts
        if: matrix.platform == 'windows'
        uses: actions/upload-artifact@v4
        with:
          name: windows-packages
          path: |
            release/build/*.exe
            release/build/*.msi
          retention-days: 90

      - name: Upload macOS artifacts
        if: matrix.platform == 'macos'
        uses: actions/upload-artifact@v4
        with:
          name: macos-packages
          path: |
            release/build/*.dmg
            release/build/*.zip
          retention-days: 90

  # Create GitHub release
  create-release:
    name: Create GitHub Release
    needs: [create-tag, build-packages]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.create-tag.outputs.tag }}

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          merge-multiple: true
          path: ./release-assets/

      - name: List release assets
        run: |
          echo "üì¶ Release assets prepared:"
          find ./release-assets/ -type f -exec ls -la {} \;

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.create-tag.outputs.tag }}
          name: 'App Shell ${{ needs.create-tag.outputs.tag }}'
          draft: false
          prerelease: ${{ needs.create-tag.outputs.prerelease }}
          generate_release_notes: true
          body: |
            ## üöÄ App Shell ${{ needs.create-tag.outputs.tag }}

            An enterprise-grade, cross-platform Electron application shell with extension support.

            ### üì• Downloads

            **Windows:**
            - `.exe` - Windows installer (recommended)
            - `.msi` - Windows MSI installer

            **macOS:**
            - `.dmg` - macOS disk image (recommended)  
            - `.zip` - macOS app bundle

            **Linux:**
            - `.AppImage` - Portable Linux application (recommended)
            - `.deb` - Debian/Ubuntu package
            - `.rpm` - Red Hat/Fedora package
            - `.snap` - Snap package

            ### ‚ú® What's New

            See the auto-generated release notes below for detailed changes.

            ### üõ†Ô∏è Installation

            1. Download the appropriate package for your operating system
            2. Install/run the application  
            3. The app shell is ready to use with extension support!

            ### üìö Documentation

            - [Extension Development Guide](https://github.com/${{ github.repository }}/blob/main/docs/extension-development.md)
            - [Contributing Guidelines](https://github.com/${{ github.repository }}/blob/main/CONTRIBUTING.md)

            ---

            **Platform Support:** Windows 10+, macOS 10.14+, Ubuntu 18.04+  
            **Architecture:** x64, ARM64 (where supported)
          files: |
            ./release-assets/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
